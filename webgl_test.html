<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGL2 Hello Triangle (View + Perspective)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  /** @type {WebGL2RenderingContext} */
  const gl = canvas.getContext("webgl2", { antialias: false, alpha: false, depth: true });
  if (!gl) { alert("WebGL2 not supported"); return; }

  // ----- Minimal mat4 (column-major, OpenGL-style) -----
  function mat4Identity() {
    const m = new Float32Array(16);
    m[0]=1; m[5]=1; m[10]=1; m[15]=1;
    return m;
  }

  function mat4Mul(a, b) { // out = a*b
    const o = new Float32Array(16);
    for (let c = 0; c < 4; c++) {
      const bc0 = b[c*4+0], bc1 = b[c*4+1], bc2 = b[c*4+2], bc3 = b[c*4+3];
      o[c*4+0] = a[0]*bc0 + a[4]*bc1 + a[8]*bc2 + a[12]*bc3;
      o[c*4+1] = a[1]*bc0 + a[5]*bc1 + a[9]*bc2 + a[13]*bc3;
      o[c*4+2] = a[2]*bc0 + a[6]*bc1 + a[10]*bc2 + a[14]*bc3;
      o[c*4+3] = a[3]*bc0 + a[7]*bc1 + a[11]*bc2 + a[15]*bc3;
    }
    return o;
  }

  function mat4Perspective(fovyRad, aspect, near, far) {
    const f = 1.0 / Math.tan(fovyRad * 0.5);
    const nf = 1.0 / (near - far);

    const m = new Float32Array(16);
    m[0]  = f / aspect;
    m[5]  = f;
    m[10] = (far + near) * nf;
    m[11] = -1.0;
    m[14] = (2.0 * far * near) * nf;
    return m;
  }

  function normalize3(v) {
    const x=v[0], y=v[1], z=v[2];
    const len = Math.hypot(x,y,z) || 1.0;
    return [x/len, y/len, z/len];
  }
  function sub3(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
  function cross3(a,b){
    return [
      a[1]*b[2]-a[2]*b[1],
      a[2]*b[0]-a[0]*b[2],
      a[0]*b[1]-a[1]*b[0],
    ];
  }
  function dot3(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

  function mat4LookAt(eye, center, up) {
    const f = normalize3(sub3(center, eye));
    const s = normalize3(cross3(f, up));
    const u = cross3(s, f);

    const m = mat4Identity();
    m[0]=s[0]; m[4]=s[1]; m[8]=s[2];
    m[1]=u[0]; m[5]=u[1]; m[9]=u[2];
    m[2]=-f[0]; m[6]=-f[1]; m[10]=-f[2];

    m[12] = -dot3(s, eye);
    m[13] = -dot3(u, eye);
    m[14] =  dot3(f, eye);
    return m;
  }

  // ----- Shaders -----
  const vs = `#version 300 es
  precision highp float;

  layout(location=0) in vec3 aPos;

  uniform mat4 uMVP;

  void main() {
    gl_Position = uMVP * vec4(aPos, 1.0);
  }`;

  const fs = `#version 300 es
  precision highp float;
  out vec4 oColor;
  void main() {
    oColor = vec4(1.0, 1.0, 1.0, 1.0);
  }`;

  function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      throw new Error(log);
    }
    return s;
  }

  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(prog));
  }

  const uMVP = gl.getUniformLocation(prog, "uMVP");

  // ----- Geometry: triangle centered at origin (in XY plane) -----
  // Equilateral-ish centered around (0,0,0)
  // skewed
  //const verts = new Float32Array([
  //   -0.2,  0.2, -1.0,
  //  -0.4, 0.5, -1.2,
  //   -0.6, 0.2, -1.0,
  //]);
  //center at origin
  const verts = new Float32Array([
     0.0,  0.6, -100.0,
    -0.6, -0.4, -1.0,
     0.6, -0.4, -1.0,
  ]);

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 3*4, 0);

  gl.bindVertexArray(null);

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
      gl.viewport(0, 0, w, h);
    }
    return { w, h };
  }

  gl.enable(gl.DEPTH_TEST);

  function frame() {
    const { w, h } = resize();
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // View + perspective
    const aspect = w / Math.max(1, h);
    const proj = mat4Perspective(60 * Math.PI/180, aspect, 0.1, 100.0);
    let view = mat4LookAt([0, 0, 2], [0, 0, 0], [0, 1, 0]);
    view = mat4Identity();
    const model = mat4Identity();

    const mvp = mat4Mul(proj, mat4Mul(view, model));

    gl.useProgram(prog);
    gl.uniformMatrix4fv(uMVP, false, mvp);

    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    gl.bindVertexArray(null);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
